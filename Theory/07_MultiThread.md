## MultiThread
### 2023. 10. 10 ~ 11 수업  
  
#### 기초  
* 앞서 봤던 예제들의 문제점 -> 이유는? : 
* 1) __다중 처리 문제__ : 두 개 이상의 클라에 대한 서비스 작업 불가
* 2) __교착 상태(DeadLock)__ : 일어나질 않을 사건에 대해 두 프로세스가 기다리는 상태
![image](https://github.com/MiyeongEom/NetworkGameProgramming/assets/112458035/825ad228-c91c-4048-b44d-160e4870d6fb)  
  
  
#### 1에 대한 해결점과 각각의 장/단점  
* 1) 서버가 하나의 클라와 통신하는 시간을 짧게 한다
  * = 매번 데이터를 보내기 전에 서버에 접속하고, 주고받은 후에 곧 바로 접속을 끊는다
  * 장점 : 구현이 가장 쉬움, 서버 시스템 자원 적게 소모
  * 단점 : 대용량 데이터 파일 전송에는 적합하지 않음, 서버에 접속하려는 클라가 많으면 접속 실패 발생률 UP (처리 지연률 증가)  
  
* 2) 서버에 접속한 클라를 스레드를 이용해 독립적으로 처리
  * 장점 : 3보다는 비교적 쉽게 구현 가능
  * 단점 : 접속한 클라 수에 비례해 스레드를 생성함 -> 시스템 자원 소모가 큼  
  
* 3) 소켓 입출력 모델 사용
  * 장점 : 하나/소수의 스레드 사용으로 다수 클라를 처리 가능함 -> 2보단 비교적 시스템 자원 소모 작음
  * 단점 : 구현의 어려움 존재  
  
  
#### 2에 대한 해결점과 각각의 장/단점  
* 1) 데이터 송/수신 부분을 잘 설계하고 교착 상태가 발생하지 않도록 한다
  * 장점 : 특별한 기법을 도입하지 않고 곧바로 구현 가능
  * 단점 : 데이터 송수신 패턴에 따라 교착 상태가 발생할 수도 -> 모든 경우에 적용 불가능함  
  
* 2) 소켓에 timeout 옵션을 적용해 send(), recv() 함수 호출 시 일정 시간이 지나면 리턴하도록 함
  * 장점 : 비교적 구현이 간단함
  * 단점 : 3에 비해 성능이 떨어짐  
  
* 3) 넌블로킹(Non-blocking) 소켓 사용
  * 장점 : 교착상태 막기
  * 단점 : 구현이 복잡, 시스템 자원(CPU 시간)을 불필요하게 낭비할 가능성 있음  
  
* 4) 소켓 입출력 모델을 사용
  * 장점 : 블로킹과 넌블로킹 소켓의 단점 보완, 교착상태 막기 가능
  * 단점 : 1보단 구현이 어려우나, 2~3보다는 쉽고 일관성 있게 구현이 가능  
  
  
#### 기본 개념  
* 윈도우의 프로세스  
  * __프로세스(Process)__ : 메모리를 비롯한 각종 리소스를 담고 있는 컨테이너(container), 정적인 개념
  * __스레드(thread)__ : 실제 CPU 시간을 할당받아 수행되는 실행 단위, 동적인 개념
  * 스레드가 프로세스에 담겨있는 리소스를 가지고 필요한 작업을 수행함
  * 하나의 윈도우 애플리케이션 실행을 위해서 최소 하나 이상의 스레드가 필요하다 -> main()/WinMain()에서 시작되는 스레드가 주 스레드(primary thread)
  * 병렬적으로 수행해야 할 경우 추가적인 스레드를 생성하고 해당 작업을 수행하게 하면 된다 -> 각 스레드의 최종 실행 상태를 저장하고 복원하는 작업을 반복 (실행 상태 : CPU레지스터 값과 스택을 비롯한 각종 정보 의미) -> 이 작업을 __컨텍스트 전환(Context Switch)__
  * 위 작업을 통해 우리의 각 스레드는 다른 스레드의 존재와 무관히 자신의 상태를 유지하며 실행 가능
  * 아래 링크를 참고하도록 하자.  
  * [여러스레드작동사진](https://github.com/MiyeongEom/NetworkGameProgramming/blob/main/Theory/07_Thread%20%EC%8B%A4%ED%96%89%20%EC%82%AC%EC%A7%84%EA%B3%BC%20%EC%84%A4%EB%AA%85.md)  
  
  
#### 스레드 생성과 종료  
* 주 스레드 이외의 스레드 f()를 생성하면 다음과 같은 정보를 운영체제에게 제공해야 한다
  * __f()함수의 시작 주소__ : 소스코드수준에서는 f() 함수의 이름이 곧 시작 주소 -> 스레드 실행 시작점이 되는 함수를 __스레드 함수(thread function)__ 이라 함
  * __f() 함수 실행 시 사용할 스택 영역 크기__ : 







```C
struct DrawingMessage(
  int type;     // = LINE
  int x1, y1;   // 직선의 시작점
  int x2, y2;   // 직선의 끝점
  int width;    // 선의 두께
  int color;    // 선의 색상
);  
```
  
